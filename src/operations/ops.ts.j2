{% from 'scripts/macros.ts.j2' import binary_op_base, unary_op_base, binary_op_class, unary_op_class, kernel_options, powint_op_base, powint_op_class, transpose_op_base, transpose_op_class, matmul_op_base %}
import { Tensor } from '../tensor';
import {
  _broadcast_shape,
  _get_original_index_from_transposed_index,
  _get_original_index,
  _get_original_index_kernel,
  _pad_shape
} from '../broadcasting';
import { Operation, BinaryOperation, UnaryOperation, nullOp, AccumulateGrad } from './base';
import * as functional from './functional';
import { registerOperation } from './registry';

// debug operations

{{ binary_op_base("__left_index__", "a_index") }}
{{ binary_op_class("__Left_index__", "__left_index__", []) }}

{{ binary_op_base("__right_index__", "b_index") }}
{{ binary_op_class("__Right_index__", "__right_index__", []) }}

// binary pointwise

{{ binary_op_base("add", "a[a_index] + b[b_index]") }}
{{ binary_op_class("Add", "add", ["aFn.backward(dz);", "bFn.backward(dz);"]) }}

{{ binary_op_base("sub", "a[a_index] - b[b_index]") }}
{{ binary_op_class("Sub", "sub", ["aFn.backward(dz);", "bFn.backward(dz.mul(new Tensor(-1)));"]) }}

{{ binary_op_base("mul", "a[a_index] * b[b_index]") }}
{{ binary_op_class("Mul", "mul", ["aFn.backward(dz.mul(b));", "bFn.backward(dz.mul(a));"]) }}

{{ binary_op_base("div", "a[a_index] / b[b_index]") }}
{{ binary_op_class("Div", "div", ["aFn.backward(dz.div(b));", "bFn.backward(dz.mul(a).mul(new Tensor(-1)).div(b).div(b));"]) }}

{{ binary_op_base("pow", "Math.pow(a[a_index], b[b_index])") }}
{{ binary_op_class("Pow", "pow", [
  "aFn.backward(dz.mul(b).mul(a.pow(b.sub(new Tensor(1)))));",
  "bFn.backward(dz.mul(a.pow(b)).mul(a.log()));"
])}}

{{ binary_op_base("fmod", "a[a_index] % b[b_index]") }}
{{ binary_op_class("Fmod", "fmod", ["aFn.backward(dz);"]) }}

{{ binary_op_base("maximum", "Math.max(a[a_index], b[b_index])") }}
{{ binary_op_class("Maximum", "maximum", ["aFn.backward(dz.mul(a.ge(b)));", "bFn.backward(dz.mul(b.gt(a)));"]) }}

{{ binary_op_base("minimum", "Math.min(a[a_index], b[b_index])") }}
{{ binary_op_class("Minimum", "minimum", ["aFn.backward(dz.mul(a.le(b)));", "bFn.backward(dz.mul(b.lt(a)));"]) }}


{{ powint_op_base() }}
{{ powint_op_class() }}

// unary pointwise

{{ unary_op_base("log", "Math.log(a[x])") }}
{{ unary_op_class("Log", "log", ["aFn.backward(new Tensor(1).div(a));"]) }}

{{ unary_op_base("sqrt", "Math.sqrt(a[x])") }}
{{ unary_op_class("Sqrt", "sqrt", ["aFn.backward(new Tensor(1).div(a.sqrt()).div(2));"]) }}

{{ unary_op_base("exp", "Math.exp(a[x])") }}
{{ unary_op_class("Exp", "exp", ["aFn.backward(dz.mul(a.exp()));"]) }}

{{ unary_op_base("square", "a[x] * a[x]") }}
{{ unary_op_class("Square", "square", ["aFn.backward(dz.mul(a).mul(new Tensor(2)));"]) }}

{{ unary_op_base("abs", "Math.abs(a[x])") }}
{{ unary_op_class("Abs", "abs", ["aFn.backward(dz.mul(functional.sign(a)));"]) }}

{{ unary_op_base("sign", "Math.sign(a[x])") }}
{{ unary_op_class("Sign", "sign", []) }}

{{ unary_op_base("neg", "-a[x]") }}
{{ unary_op_class("Neg", "neg", ["aFn.backward(dz.mul(new Tensor(-1)));"]) }}

{{ unary_op_base("reciprocal", "1 / a[x]") }}
{{ unary_op_class("Reciprocal", "reciprocal", ["aFn.backward(dz.mul(a.pow(-2)));"]) }}

export class Reshape extends Operation {
  protected _forward(a: Tensor, shape: number[]) {
    const previous_length = a.dataLength();
    const target_length = shape.reduce((acc, val) => acc * val, 1);

    if (previous_length !== target_length) {
      throw new Error('Shape mismatch: ' + a.shape + ' and ' + shape);
    }

    if (a.requires_grad) {
      this.saved_tensors = [a];
    }
    if (a.grad_fn) {
      this.next_functions.push(a.grad_fn);
    } else if (a.requires_grad) {
      const acc = new AccumulateGrad();
      acc.variable = a;
      this.next_functions.push(acc);
    } else {
      this.next_functions.push(nullOp);
    }

    return new Tensor(
      a.data,
      { requires_grad: a.requires_grad },
      { operation: a.requires_grad ? this : null, shape }
    );
  }
  protected _backward(dz: Tensor) {
    const [a] = this.saved_tensors;
    const [aFn] = this.next_functions;

    // backward_operations:
    aFn.backward(dz.reshape(a.shape));
  }
}
registerOperation('reshape', Reshape);

export class Unsqueeze extends Operation {
  protected _forward(a: Tensor, dim: number) {
    if (a.requires_grad) {
      this.saved_tensors = [a];
    }
    if (a.grad_fn) {
      this.next_functions.push(a.grad_fn);
    } else if (a.requires_grad) {
      const acc = new AccumulateGrad();
      acc.variable = a;
      this.next_functions.push(acc);
    } else {
      this.next_functions.push(nullOp);
    }

    if (dim < 0) {
      dim += a.shape.length + 1;
    }

    const shape = [...a.shape];
    shape.splice(dim, 0, 1);

    return new Tensor(
      a.data,
      { requires_grad: a.requires_grad },
      { operation: a.requires_grad ? this : null, shape }
    );
  }
  protected _backward(dz: Tensor) {
    const [a] = this.saved_tensors;
    const [aFn] = this.next_functions;

    // backward_operations:
    aFn.backward(dz.reshape(a.shape));
  }
}
registerOperation('unsqueeze', Unsqueeze);

// trigonometric

{{ unary_op_base("sin", "Math.sin(a[x])") }}
{{ unary_op_class("Sin", "sin", ["aFn.backward(dz.mul(a.cos()));"]) }}

{{ unary_op_base("cos", "Math.cos(a[x])") }}
{{ unary_op_class("Cos", "cos", ["aFn.backward(dz.mul(a.sin().neg()));"]) }}

{{ unary_op_base("tan", "Math.tan(a[x])") }}
{{ unary_op_class("Tan", "tan", ["aFn.backward(dz.mul(a.cos().pow(-2)));"]) }}

// reduction

function _sum_tensor(a: Tensor, operation: Operation | null = null): Tensor {
  return new Tensor(
    a.toArray().reduce((acc, val) => acc + val, 0),
    { requires_grad: a.requires_grad },
    { operation: operation }
  );
}

{{ unary_op_class("Sum", "sum", ["const result = new Tensor(Array(a.dataLength()).fill(dz.item()));", "aFn.backward(result);"]) }}

function _mean_tensor(a: Tensor, operation: Operation | null = null): Tensor {
  return new Tensor(
    a.toArray().reduce((acc, val) => acc + val, 0) / a.dataLength(),
    { requires_grad: a.requires_grad },
    { operation: operation }
  );
}

{{ unary_op_class("Mean", "mean", ["const result = new Tensor(Array(a.dataLength()).fill(dz.item() / a.dataLength()));", "aFn.backward(result);"]) }}

// linalg

{{ transpose_op_base() }}
{{ transpose_op_class() }}

{{ matmul_op_base() }}
{{ binary_op_class("Matmul", "matmul", []) }}

// comparison

{{ binary_op_base("lt", "(a[a_index] < b[b_index]) ? 1 : 0") }}
{{ binary_op_class("Lt", "lt", []) }}

{{ binary_op_base("gt", "(a[a_index] > b[b_index]) ? 1 : 0") }}
{{ binary_op_class("Gt", "gt", []) }}

{{ binary_op_base("le", "(a[a_index] <= b[b_index]) ? 1 : 0") }}
{{ binary_op_class("Le", "le", []) }}

{{ binary_op_base("ge", "(a[a_index] >= b[b_index]) ? 1 : 0") }}
{{ binary_op_class("Ge", "ge", []) }}

{{ binary_op_base("eq", "(a[a_index] == b[b_index]) ? 1 : 0") }}
{{ binary_op_class("Eq", "eq", []) }}

{{ binary_op_base("ne", "(a[a_index] != b[b_index]) ? 1 : 0") }}
{{ binary_op_class("Ne", "ne", []) }}
